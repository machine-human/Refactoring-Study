# 여러 겹의 조건문을 보호 구문으로 전환

###### Replace Nested Conditional with Guard Clauses

메서드에 조건문이 있어서 정상적인 실행 경로를 파악하기 힘들 땐 모든 특수한 경우에 보호 구문을 사용하자

</br>

[보기]

- 변경 전

  ```java
  double getPayAmount() {
  	double result;
  
  	if (isDead) {
  		result = deadAmount();
  	} else {
  		if (isSeparated) {
  			result = separatedAmount();
  		} else {
  			if (isRetired) {
  				result = retiredAmount();
  			} else {
  				result = normalPayAmount();
  			}
  		}
  	}
  	return result;
  }
  ```

- 변경 후

  ```java
  double getPayAmount() {
  	double result;
  
  	if (isDead) {
  		return deadAmount();
  	}
  
  	if (isSeparated) {
  		return separatedAmount();
  	}
  
  	if (isRetired) {
  		return retiredAmount();
  	}
  
  	return normalPayAmount();
  }
  ```

</br>


[방법]

1. 조건 절마다 보호 구문을 넣자
   (그 보호 구문은 값을 반환하거나 예외를 통지함)

</br>

2. 각 조건 절을 보호 구문으로 바꿀 때마다 컴파일과 테스트를 실시하자
   (모든 보호 구문의 결과가 같다면 중복 조건식 통합 기법 실시)

</br>

[예제]

- 수정 전

  ```java
  public class Example01 {
      double getPayAmount() {
          double result;
          boolean isDead = false;
          boolean isSeparated = true;
          boolean isRetired = true;
  
          if (isDead) {
              result = deadAmount();
          } else {
              if (isSeparated) {
                  result = separatedAmount();
              } else {
                  if (isRetired) {
                      result = retiredAmount();
                  } else {
                      result = normalPayAmount();
                  }
              }
          }
          return result;
      }
  
      private double separatedAmount() {
          return 0;
      }
  
      private double normalPayAmount() {
          return 0;
      }
  
      private double retiredAmount() {
          return 0;
      }
  
      private double deadAmount() {
          return 0;
      }
  }
  ```

</br>

- 수정 후

  ```java
  public class Example01 {
      double getPayAmount() {
          double result;
          boolean isDead = false;
          boolean isSeparated = true;
          boolean isRetired = true;
  
          if (isDead) return deadAmount();
          if (isSeparated) return separatedAmount();
          if (isRetired) return retiredAmount();
          return normalPayAmount();
      }
  
      private double separatedAmount() {
          return 0;
      }
  
      private double normalPayAmount() {
          return 0;
      }
  
      private double retiredAmount() {
          return 0;
      }
  
      private double deadAmount() {
          return 0;
      }
  }
  ```

</br>



[예제 - 조건문을 역순으로 만들기]

- 수정 전

  ```java
  public class Example02 {
      public double getAdjustedCapital() {
          double result = 0.0;
          double capital = 1.0;
          double intRate = 1.0;
          double duration = 1.0;
          int income = 10;
          final int ADJ_FACTOR = 2;
  
          if (capital > 0.0) {
              if (intRate > 0.0 && duration > 0.0) {
                  result = (income / duration) * ADJ_FACTOR;
              }
          }
          return result;
      }
  }
  ```

</br>

- 수정 후

  ```java
  public class Example02 {
      public double getAdjustedCapital() {
          double capital = 1.0;
        double intRate = 1.0;
          double duration = 1.0;
          int income = 10;
          final int ADJ_FACTOR = 2;
  
          if (capital > 0.0) return 0.0;
          if (intRate <= 0.0 || duration <= 0.0) return 0.0;
          return (income / duration) * ADJ_FACTOR;
      }
  }
  ```