# 조건문을 재정의로 전환

###### Replace Conditional with Polymorphism

객체 타입에 따라 다른 기능을 실행하는 조건문이 있을 땐
조건문의 각 절을 하위 클래스의 재정의 메서드 안으로 옳기고, 원본 메서드는 abstract 타입으로 수정하자

</br>

[보기]

```java
    int getSpeed() {
        switch (type) {
            case EUROPEAN:
                return getBaseSpeed();
            case AFRICAN:
                return getBaseSpeed() - getLoadFactor() * numberOfCoconuts;
            case NORWEGIAN_BLUE:
                return (isNailed) ? 0 : getBaseSpeed(voltage);
        }
        throw new RuntimeException("없는 사원입니다.");
    }
```

</br>

![Replace Conditional with Polymorphism.PNG](https://raw.githubusercontent.com/machine-human/Refactoring-Study/master/image/Replace%20Conditional%20with%20Polymorphism.PNG)

</br>

[방법]

1. 조건문이 메서드 코드의 일부라면 그 조건문을 따로 떼서 메서드 추출을 적용

</br>

2. 필요하다면 메서드 이동을 적용해서 조건문을 최상위 클래스로 옮기자

</br>

3. 하위클래스 중 하나를 택해서 그 안에 조건 메서드를 재정의하는 메서드를 작성

</br>

4. 조건문의 해당 절에 있는 코드를 그 하위 클래스 메서드로 옮기고 적절히 수정
   (이를 위해 상위 클래스의 일부 private 메서드를 protected로 수정해야 할 수도 있음)

</br>

5. 컴파일과 테스트 실시

</br>

6. 조건무늬 나머지 절으 ㅣ코드도 마찬가지로 하위클래스 메서드 안으로 옮기자

</br>

7. 상위클래스 메서드를 abstract 타입으로 만들자

</br>

[예제]

- 수정 전

  ```java
  public class Employee {
      int monthlySalary = 0;
      int commission = 0;
      int bonus = 100;
      private EmployeeType type;
  
      Employee(EmployeeType type) {
          this.type = type;
      }
  
      int payAmount() {
          switch (getTypeCode()) {
              case EmployeeType.ENGINEER:
                  return monthlySalary;
              case EmployeeType.SALESMAN:
                  return monthlySalary + commission;
              case EmployeeType.MANAGER:
                  return monthlySalary + bonus;
              default:
                  throw new RuntimeException("없는 사원입니다.");
          }
      }
  
      private int getTypeCode() {
          return type.getTypeCode();
      }
  }
  ```
  
  ```java
  public abstract class EmployeeType {
      abstract int getTypeCode();
  
      static final int ENGINEER = 0;
      static final int SALESMAN = 1;
      static final int MANAGER = 2;
  }
  
  class Engineer extends EmployeeType {
      @Override
      int getTypeCode() {
          return EmployeeType.ENGINEER;
      }
  }
  
  class Salesman extends EmployeeType {
      @Override
      int getTypeCode() {
          return EmployeeType.SALESMAN;
      }
  }
  
  class Manager extends EmployeeType {
      @Override
      int getTypeCode() {
          return EmployeeType.MANAGER;
      }
  }
  ```

</br>

- 수정 후

  ```java
  public class Employee {
      int monthlySalary = 0;
      int commission = 0;
      int bonus = 100;
      private EmployeeType type;
  
      Employee(EmployeeType type) {
          this.type = type;
      }
  
      int payAmount() {
          return type.payAmount(this);
      }
  
      public int getMonthlySalary() {
          return monthlySalary;
      }
  
      public int getCommission() {
          return commission;
      }
  
      public int getBonus() {
          return bonus;
      }
  
      private int getTypeCode() {
          return type.getTypeCode();
      }
  }
  ```
  
  ```java
  public abstract class EmployeeType {
      static final int ENGINEER = 0;
      static final int SALESMAN = 1;
      static final int MANAGER = 2;
  
      abstract int getTypeCode(Employee emp);
  
      int payAmount(Employee emp) {
          switch (getTypeCode(emp)) {
              case EmployeeType.ENGINEER:
                  throw new RuntimeException("재정의해야 함");
              case EmployeeType.SALESMAN:
                  throw new RuntimeException("");
              case EmployeeType.MANAGER:
                  throw new RuntimeException("");
              default:
                  throw new RuntimeException("없는 사원입니다.");
          }
      }
  }
  
  
  class Engineer extends EmployeeType {
      @Override
      int getTypeCode(Employee emp) {
          return EmployeeType.ENGINEER;
      }
  
      @Override
      int payAmount(Employee emp) {
          return emp.getMonthlySalary();
      }
  }
  
  class Salesman extends EmployeeType {
      @Override
      int getTypeCode(Employee emp) {
          return EmployeeType.SALESMAN;
      }
  
      @Override
      int payAmount(Employee emp) {
          return emp.monthlySalary + emp.getCommission();
      }
  }
  
  class Manager extends EmployeeType {
      @Override
      int getTypeCode(Employee emp) {
          return EmployeeType.MANAGER;
      }
  
      @Override
      int payAmount(Employee emp) {
          return emp.monthlySalary + emp.getBonus();
      }
  }
  ```
