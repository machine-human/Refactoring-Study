# 하위클래스 추출

###### Extract Subclass

일부 인스턴스에만 사용되는 기능이 든 클래스가 있을 땐 그 기능 부분을 전담하는 하위클래스를 작성

</br>

[클래스 다이어그램]

![Extract Subclass.PNG](https://raw.githubusercontent.com/machine-human/Refactoring-Study/master/image/Extract%20Subclass.PNG)

</br>

[방법]

1. 원본 클래스에 새 하위클래스를 정의

</br>

2. 그 하위클래스에 생성자 메서드를 작성

   (간단할 땐 상위클래스의 인자를 복사하고 super를 사용해서 상위클래스의 생성자를 호출)

   (하위클래스를 사용한다는 사실을 클라이언트가 모르게 은닉하려면)

   (생성자를 팩토리 메서드로 전환을 적용)

</br>

3. 상위클래스의 생성자를 호출하는 부분을 전부 찾자

</br>

4. 그 부분이 하위클래스를 사용한다면 새로 작성한 생성자 호출로 고치자

   (하위클래스의 생성자가 다른 인자를 받아야 할 땐 메서드명 변경을 적용해서 생성자명을 변경)

   (상위클래스의 생성자 매개변수 중 일부가 더 이상 필요 없어졌을 때도 메서드명 변경을 적용)

   (상위클래스를 직접 인스턴스화될 수 없게 됐을 땐 상위클래스를 abstract 타입으로 바꾸자)

</br>

5. 메서드 하향과 필드 하향을 차례로 적용해서 기능을 하위클래스로 옮기자

   (클래스 추출과 달리 보통은 메서드에 먼저 적용하고 데이터엔 나중에 적용하는 것이 간편)

   (public 메서드를 하위클래스로 옮길 때,)

   (호출 부분의 변수나 매개변수 타입을 새로 정의해서 새 메서드를 호출해야 할 수도 있음)

   (이렇게 해야 할 경우는 컴파일러가 잡아 냄)

</br>

6. 계층구조가 현재 나타나는 정보 (부울값이나 분류 부호)가 저장되는 필드가 있는지 찾자

</br>

7. 필드 자체 캡슐화를 실시해서 그 필드를 제거하고 속성 읽기 메서드를 다형적인 상수 메서드로 교체하자

</br>

8. 이 필드를 사용하는 모든 부분을 대상으로 조건문을 재정의로 전환을 실시해야 함

   (읽기 메서드를 사용하는 클래스 밖의 모든 메서드에 메서드 이동을 적용해서 그 클래스로 옮길지 고려)

   (그 다음, 조건문을 재정의로 전환을 실시)

</br>

9. 각 메서드를 하위클래스로 내릴 때마다 컴파일과 테스트를 실시

</br>

[예제]

- 수정 전

  ```java
  public class Employee {
      private int rate;
  
      public Employee(int rate) {
          this.rate = rate;
      }
  
      public int getRate() {
          return rate;
      }
  }
  ```
  
  ```java
  public class Execute {
  	public static void main(String[] args) {
  		Employee kent = new Employee(5);
  		JobItem jobItem = new JobItem(0, 5, true, kent);
  	}
  }
  ```
  
  ```java
  public class JobItem {
      private int unitPrice;
      private int quantity;
      private Employee employee;
      private boolean isLabor;
  
      public JobItem(int unitPrice, int quantity, boolean isLabor, Employee employee) {
          this.unitPrice = unitPrice;
          this.quantity = quantity;
          this.isLabor = isLabor;
          this.employee = employee;
      }
  
      public int getTotalPrice() {
          return getUnitPrice() * quantity;
      }
  
      public int getUnitPrice() {
          return (isLabor) ? employee.getRate() : unitPrice;
      }
  
      public int getQuantity() {
          return quantity;
      }
  
      public Employee getEmployee() {
          return employee;
      }
  }
  ```

</br>

- 수정 후

  ```java
  public class Employee {
      private int rate;
  
      public Employee(int rate) {
          this.rate = rate;
      }
  
      public int getRate() {
          return rate;
      }
  }
  ```
  
  ```c++
  public class Execute {
  	public static void main(String[] args) {
  		Employee kent = new Employee(5);
  		JobItem j1 = new LaborItem(0, 5, true, kent);
  		JobItem j2 = new JobItem(10, 15);
  	}
  }
  ```
  
  ```java
  public class JobItem {
      private int unitPrice;
      private int quantity;
      protected Employee employee;
  
      //하위클래스가 기존 생성자를 사용하기 때문에
      //public -> protected로 변경
      protected JobItem(int unitPrice, int quantity) {
          this.unitPrice = unitPrice;
          this.quantity = quantity;
      }
  
      public int getTotalPrice() {
          return getUnitPrice() * quantity;
      }
  
      public int getUnitPrice() {
          return unitPrice;
      }
  
      public int getQuantity() {
          return quantity;
      }
  
      public Employee getEmployee() {
          return employee;
      }
      protected boolean isLabor() {
          return false;
      }
  }
  
  //그닝과 데이터 중 일부가 LaborItem 클래스에만 사용되기 때문에 LaborItem 클래스 추가
  class LaborItem extends JobItem{
  
      public LaborItem(int quantity, Employee employee) {
          super(0, quantity);
          super.employee = employee;
      }
      public int getEmployee() {
          return employee.getRate();
      }
      protected boolean isLabor() {
          return true;
      }
  }
  ```