# 메서드 상향

###### Pull Up Method

기능이 같은 메서드가 여러 하위클래스에 들어 있을 땐 그 메서드를 상위클래스로 옮기자

</br>

[클래스 다이어그램]

![Pull Up Method.PNG](https://raw.githubusercontent.com/machine-human/Refactoring-Study/master/image/Pull%20Up%20Method.PNG)

</br>

[방법]

1. 메서드가 서로 같은지 검사
   
   (거의 비슷한데 똑같진 않다면 한 메서드에 알고리즘 전환을 적용해서 메서드를 똑같게 만들기)

</br>

2. 메서드의 시그너처가 서로 다르다면 모든 시그너처를 상위클래스에 사용하고자 하는 시그너처로 수정

</br>

3. 상위클래스 안에 새 메서드를 작성하고

</br>

4. 새 메서드 안에 같은 메서드의 내용을 복사한 후 적절히 수정하고 컴파일

   (철저한 타입 선언을 요하는 언어로 작업 중일 때 그 메서드가 두 하위클래스엔 있고)

   (상위클래스엔 없는 다른 메서드를 호출한다면 상위클래스에 abstract 타입의 메서드를 선언하자)

   (메서드가 하위클래스의 필드를 사용한다면 필드 상향 or 필드 자체 캡슐화를 적용하고)

   (abstract 타입의 일기 메서드를 선언해 사용)

</br>

5. 하위클래스의 메서드를 하나 삭제

</br>

6. 컴파일과 테스트를 실시

</br>

7. 상위클래스의 메서드만 남을 때까지 하위클래스 메서드를 계속 삭제

</br>

8. 상위클래스 메서드를 호출하는 부분을 보면서 필요한 타입을 상위클래스로 수정할 수 있는지 파악

</br>



[예제]

- 수정 전

  ```java
  public class Customer {
  
  }
  
  class Regular extends Customer {
      //createBill 메서드는 상위클래스로 올려보낼 수 없음
      //chargeFor 메서드가 하위클래스 마다 다르기 때문
      void createBill(Date date) {
          double chargeAmount = chargeFor(date);
      }
  
      double chargeFor(Date date) {
          Date now = new Date();
          if (date.after(now)) {
              return 1;
          } else {
              return 0;
          }
      }
  }
  
  class Preferred extends Customer {
      //createBill 메서드는 상위클래스로 올려보낼 수 없음
      //chargeFor 메서드가 하위클래스 마다 다르기 때문
      void createBill(Date date) {
          double chargeAmount = chargeFor(date);
      }
  
      double chargeFor(Date date) {
          Date now = new Date();
          if (date.after(now)) {
              return 2;
          } else {
              return 0;
          }
      }
  }
  ```

</br>

- 수정 후

  - 상위클래스의 chargeFor() 메서드를 abstract로 선언
  - 하위 클래스에서 오버라이드 후 기존 메서드 복사
  
  ```java
  public abstract class Customer {
      abstract double chargeFor(Date date);
  
      void createBill(Date date) {
          double chargeAmount = chargeFor(date);
      }
  }
  
  class Regular extends Customer {
      @Override
      double chargeFor(Date date) {
          Date now = new Date();
          if (date.after(now)) {
              return 1;
          } else {
              return 0;
          }
      }
  }
  
  class Preferred extends Customer {
      @Override
      double chargeFor(Date date) {
          Date now = new Date();
          if (date.after(now)) {
              return 2;
          } else {
              return 0;
          }
      }
  }
  ```
