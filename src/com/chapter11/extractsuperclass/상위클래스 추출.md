# 상위클래스 추출

###### Extract Superclass

기능이 비슷한 두 클래스가 있을 땐 상위클래스를 작성하고 공통된 기능들을 그 상위클래스로 옮기자

</br>

[클래스 다이어그램]

![Extract Superclass.PNG](https://raw.githubusercontent.com/machine-human/Refactoring-Study/master/image/Extract%20Superclass.PNG)

</br>

[방법]

1. 빈 abstract 타입의 상위클래스를 작성

</br>

2. 원본 클래스들은 이 상위클래스의 하위클래스로 만들자

</br>

3. 필드 상향, 메서드 상향, 생성자 내용 상향을 차례로 적용해서 공통된 요소를 상위클래스로 옮기자

</br>

4. 메서드를 상위클래스로 옮길 때마다 컴파일과 테스트를 실시

</br>

5. 하위클래스에 남아 있는 메서드마다 검사하면서 공통된 부분이 있는지 확인하고,

</br>

6. 만약 있으면 그 공통 부분에 메서드 추출과 메서드 상향을 차례로 적용

</br>

7. 전체적인 흐름이 비슷하다면 템플릿 메서드 혀성을 실시하는 것도 괜찮음

</br>

8. 모든 공통 요소를 상위클래스로 옮긴 후 하위클래스를 사용하는 각 부분을 검사

</br>

9. 하위클래스 사용 부분이 공통 인터페이스만 사용한다면 

   필요한 그 인터페이스의 타입을 상위클래스의 타입으로 변경

</br>

[예제]

- 수정 전

  ```java
  public class Department {
  	private String name;
  	private Vector staff = new Vector();
  
  	public Department(String name) {
  		this.name = name;
  	}
  
  	public int getTotalAnnualCost() {
  		Enumeration e = getStaff();
  		int result = 0;
  		while (e.hasMoreElements()) {
  			Employee each = (Employee) e.nextElement();
  			result += each.getAnnualCost();
  		}
  		return result;
  	}
  
  	public int getHeadCount() {
  		return staff.size();
  	}
  
  	public Enumeration getStaff() {
  		return staff.elements();
  	}
  
  	public void addStaff(Employee arg) {
  		staff.addElement(arg);
  	}
  
  	public String getName() {
  		return name;
  	}
  }
  ```
  
  ```java
  public class Employee {
      private String name;
      private int annualCost;
      private String id;
  
      public Employee(String name, String id, int annualCost) {
          this.name = name;
          this.id = id;
          this.annualCost = annualCost;
      }
  
      public int getAnnualCost() {
          return annualCost;
      }
  
      public String getId() {
          return id;
      }
  
      public String getName() {
          return name;
      }
  }
  ```

</br>

- 수정 후

  - 새로운 Party 상위 클래스 작성 후 기존 상위 클래스는 새 상위클래스 안에 넣음
  
  ```java
  public class Department extends Party {
      private String name;
      private Vector staff = new Vector();
  
      public Department(String name) {
          super(name);
      }
  
      @Override
      public int getAnnualCost() {
          Enumeration e = getStaff();
          int result = 0;
          while (e.hasMoreElements()) {
              Employee each = (Employee) e.nextElement();
              result += each.getAnnualCost();
          }
          return result;
      }
  
      public int getHeadCount() {
          return staff.size();
      }
  
      public Enumeration getStaff() {
          return staff.elements();
      }
  
      public void addStaff(Employee arg) {
          staff.addElement(arg);
      }
  
      public String getName() {
          return name;
      }
  }
  
  ```
  
  ```c++
  public class Employee extends Party {
      private String name;
      private int annualCost;
      private String id;
  
      public Employee(String name, String id, int annualCost) {
          super(name);
          this.id = id;
          this.annualCost = annualCost;
      }
  
      public int getAnnualCost() {
          return annualCost;
      }
  
      public String getId() {
          return id;
      }
  
      public String getName() {
          return name;
      }
  }
  ```
  
  ```java
  abstract class Party {
      private String name;
  
      protected Party(String name) {
          this.name = name;
      }
  
      //Employee 클래스와 Department 클래스에 모두 존재하는
      //getName 메서드에 메서드 상향 적용
      public String getName() {
          return name;
      }
  
      abstract public int getAnnualCost();
  }
  ```
