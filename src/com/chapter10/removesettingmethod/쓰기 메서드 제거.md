# 쓰기 메서드 제거 

###### Remove Setting Method 

생성할 때 지정한 필드 값이 절대로 변경되지 말아야할 땐
그 필드를 설정하는 모든 쓰기 메서드를 삭제하자

</br>

[클래스 다이어그램]

![Remove Setting Method.PNG](https://raw.githubusercontent.com/machine-human/Refactoring-Study/master/image/Remove%20Setting%20Method.PNG)

</br>


[방법]

1. 쓰기 메서드가 생성할 때나 생성자가 호출하는 메서드에서만 호출되는지 검사

</br>

2. 컴파일과 테스트 실시

</br>

3. 쓰기 메서드가 생성자 안이나 생성자가 호출한 메서드 안에서만 호출되는지 검사

</br>

4. 변수에 직접 접근할 수 있게 생성자를 수정
   (상위클래스의 private 필드를 설정하는 하위클래스가 있으면 생서자를 변수에 직접 접근하게 수정할 수 없음)
   (이럴 땐 상위클래스에 private 필드 값을 설정하는 protected 메서드(실제론 생성자)를 넣어야 한다)
   (상위 클래스 메서드명은 쓰기 메서드와 혼동되지 않는 이름으로 정하자)

</br>

5. 컴파일과 테스트 실시

</br>

6. 쓰기 메서드 삭제 후 컴파일

</br>

[예제 - 1]

- 수정 전

  ```java
  public class Example01 {
      private String id;
  
      Example01(String id) {
          setId(id);
      }
  
      void setId(String arg) {
          id = arg;
      }
  }
  ```

</br>

- 수정 후

  - 쓰기 메서드 삭제
  - 변수에 직접 접근할 수 있게 생성자를 수정
  
  ```java
  public class Example01 {
      private final String id;
  
      Example01(String id) {
          this.id = id;
      }
  }
  ```
  

</br>

[예제 - 2]

- 수정 전

  ```java
  public class Example02 extends Example01 {
      private double interestRate;
  
      Example02(String id, double rate) {
          setId(id);
          this.interestRate = rate;
      }
  }
  ```

</br>

- 수정 후

  - 하위클래스가 상위클래스의 private 변수를 초기화 할때는
  - private 변수에 직접 접근해서 값을 설정할 수 없으므로
  - 상위 클래스 생성자를 이용
  
```java
  public class Example02 extends Example01 {
      private double interestRate;
  
      Example02(String id, double rate) {
          //최선의 방법은 상위클래스 생성자를 이용
          //setId(id);
          super(id);
          this.interestRate = rate;
      }
  }
```
