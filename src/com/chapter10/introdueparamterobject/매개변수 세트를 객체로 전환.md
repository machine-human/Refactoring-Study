# 매개변수 세트를 객체로 전환

######  Introduce Paramter Object

여러 개의 매개변수가 항상 붙어 다닐 땐 그 매개변수들을 객체로 바꾸자

</br>

[클래스 다이어그램]

![Introduce Parameter Object.PNG](https://raw.githubusercontent.com/machine-human/Refactoring-Study/master/image/Introduce%20Parameter%20Object.PNG)

</br>


[방법]

1. 대체할 매개변수 그룹에 해당하는 새 클래스를 작성하고, 그 클래스를 변경불가로 만들자

</br>

2. 컴파일하자

</br>

3. 새 데이터 뭉치에 매개변수 추가를 적용하자

</br>

4. 새 매개변수에 기본 값을 사용하자

   (호출 부분이 많으면 기존 시그너처를 그대로 두고 새 메서드를 호출하게 하자)
   
   (그 리팩토링을 기존 메서드에 먼저 적용하자)
   
   (그런 다음 호출 부분들을 하나씩 옮긴 후 기존 메서드는 삭제하면 된다)

</br>

5. 데이터 뭉치 안의 각 매개변수마다 시그너처에서 해당 매개변수를 삭제하자

</br>

6. 그 값 대신 매개변수 객체를 사용하게 호출 부분과 메서드 내용을 수정하자

</br>

7. 매개변수를 옮길 때마다 컴파일과 테스트를 실시

</br>

8. 매개변수 삭제를 전부 완료했으면, 메서드이동을 적용하여 매개변수 객체로 옮길 수 있는 기능을 찾자

   (매개변수 객체로 옮길 수 있는 기능은 메서드 전체일 수도 있고 일부분일 수도 있음)
   
   (메서드의 일부분일 경우 우선 메서드 추출을 실시한 후 새로 빼낸 메서드로 옮기면 됨)

</br>

[예제]

- 수정 전

  ```java
  public class Account {
      private Vector entries = new Vector();
  
      double getFlowBetween(Date start, Date end) {
          double result = 0;
          Enumeration e = entries.elements();
          while (e.hasMoreElements()) {
              Entry each = (Entry) e.nextElement();
              if (each.getDate().equals(start) || each.getDate().equals(end) ||
                      (each.getDate().after(start) && each.getDate().before(end))) {
                  result += each.getValue();
              }
          }
          return result;
      }
  }
  ```
  
  ```c++
  public class Entry {
      private Date chargeDate;
      private double value;
  
      public Entry(double value, Date chargeDate) {
          value = value;
          chargeDate = chargeDate;
      }
  
      Date getDate() {
          return chargeDate;
      }
  
      double getValue() {
          return value;
      }
  }
  ```
  
  ```c++
  public class Execute {
      public static void main(String[] args) {
          Date startDate = new Date();
          Date endDate = new Date();
  
          Account anAccount = new Account();
          double flow = anAccount.getFlowBetween(startDate, endDate);
      }
  }
  ```

</br>

- 수정 후

  - 범위를 처리하는 데이터 클래스 DateRange 생성
  - 모든 값을 final로 선언하고 생성자 안에 지정
  - 그래서 값을 변경하는 메서드가 없음
  - 이 리팩토링을 적용하려면 반드시 DateRange 클래스를 변경불가로 만들어야 함
  - getFlowBetween(Date start, Date end) 부분에 파라미터로 DateRang 를 추가하고
  - start 부터 하나씩 제거 하면서 수정
  
  ```java
  public class Account {
      private Vector entries = new Vector();
  
      double getFlowBetween(DateRange range) {
          double result = 0;
          Enumeration e = entries.elements();
          while (e.hasMoreElements()) {
              Entry each = (Entry) e.nextElement();
              if (range.includes(each.getDate())) {
                  result += each.getValue();
              }
          }
          return result;
      }
  }
  ```
  
  ```c++
  public class DateRange {
      //모든 값을 final로 선언하고 생성자 안에 지정
      //그래서 값을 변경하는 메서드가 없음
      //이럴 경우 각종 별칭 버그가 방지되어 좋음
      private final Date start;
      private final Date end;
  
      public DateRange(Date start, Date end) {
          this.start = start;
          this.end = end;
      }
  
      Date getStart() {
          return start;
      }
  
      Date getEnd() {
          return end;
      }
  
      //매개변수 나열 부분을 객체로 전환하는 작업 후
      //기능을 새 객체의 다른 메서드로 옮기는 작업을 추가로 실시한다면 더욱 효과적
      boolean includes(Date arg) {
          return (arg.equals(start) || arg.equals(end) || (arg.after(start) && arg.before(end)));
      }
  }
  ```
  
  ```c++
  public class Entry {
      private Date chargeDate;
      private double value;
  
      public Entry(double value, Date chargeDate) {
          value = value;
          chargeDate = chargeDate;
      }
  
      Date getDate() {
          return chargeDate;
      }
  
      double getValue() {
          return value;
      }
  }
  ```
  
  ```java
  public class Execute {
      public static void main(String[] args) {
          Date startDate = new Date();
          Date endDate = new Date();
  
          Account anAccount = new Account();
          double flow = anAccount.getFlowBetween(new DateRange(startDate, endDate));
      }
  }
  ```
