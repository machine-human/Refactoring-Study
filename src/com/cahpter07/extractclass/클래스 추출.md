# 클래스 추출

###### Extract Class

두 클래스가 처리해야 할 기능이 하나의 클래스에 들어 있을 땐 새 클래스를 만들고 기존 클래스의 관련 필드와 메서드를 새 클래스로 옮기자

</br>

[클래스 다이어그램]

![Extract Class.png](https://raw.githubusercontent.com/machine-human/Refactoring-Study/master/image/Extract%20Class.PNG)


</br>


[방법]

1. 원본 클래스에서 새 클래스로의 링크를 만들자
   
   (양방향 링크를 만들어야 할 수 도있지만, 필요할 때까진 역방향 링크를 만들자)

</br>

2. 옮길 필드마다 필드 이동 기법 적용하자

</br>

3. 필드를 하나씩 옮길 때마다 컴파일과 테스트 실시

</br>

4. 메서드 이동 기법을 실시해서 원본 클래스의 메서드를 새 클래스로 옮기자

</br>

5. 그 후 하급 메서드(피호출 메서드)부터 시작해서 상급 메서드 (호출 메서드)에 적용하자

</br>

6. 각 클래스를 다시 검사해서 인터페이스를 줄이자
   (이때 양방향 링크가 있다면 단반향으로 바꿀 수 있는지 알아보자)

</br>

7. 여러 곳에서 클래스에 접근할 수 있게 할지 결정하자

</br>

8. 여러 곳에 접근할 수 있게 할 경우, 새 클래스를 참조 객체나 변경불가 값 객체로서 공개 여부 결정하자

</br>

[예제]

- 수정 전

  ```java
  public class Person...
      private String name;
      private String officeAreaCode;
      private String officeNumber;
  
      public String getName() {
          return name;
      }
  
      public String getTelephoneNumber() {
          return ("(" + officeAreaCode + ") " + officeNumber);
      }
  
      String getOfficeAreaCode() {
          return officeAreaCode;
      }
  
      void setOfficeAreaCode(String officeAreaCode) {
          this.officeAreaCode = officeAreaCode;
      }
  
      String getOfficeNumber() {
          return officeNumber;
      }
  
      void setOfficeNumber(String officeNumber) {
          this.officeNumber = officeNumber;
      }
  ...
  ```

</br>

- 수정 후

  - TelephoneNumber 클래스 생성 후 Person 클래스로부터 전화번호 기능을 떼어냄
  - 이후 Person 클래스에서 TelephoneNumber 클래스로의 링크를 작성
  - officeAreaCode, officeNumber 필드도 TelephoneNumber 클래스로 이동 (메서드 포함)
  - 마지막으로 새 클래스를 클라이언트에 어느 정도 공개할지 결정
  
  ```java
  public class Person ...   
      private String name;  
      private TelephoneNumber officeTelephone = new TelephoneNumber();  
      
      public String getName() {    
          return name;   
      }  
      
      public String getTelephoneNumber() {  
          return officeTelephone.getTelephoneNumber(); 
      }  
      
    TelephoneNumber getOfficeNumber() {    
          return officeTelephone;  
      }
  ...
  ```
  
  ```java
  public class TelephoneNumber ...
      private String areaCode;  
      private String number; 
      
      public String getTelephoneNumber() { 
          return ("(" + areaCode + ") " + number); 
      }  
      
      public String getNumber() {  
          return number;   
      }  
      
      public void setNumber(String number) {   
          this.number = number;
      }  
      
      public String getAreaCode() {    
          return areaCode;  
      } 
      
      public void setAreaCode(String areaCode) { 
          this.areaCode = areaCode;   
      }
  ...
  ```



</br>

[저자 왈 - 1]

- 새 클래스를 클라이언트에 공개하는 방식을 사용할 땐 왜곡의 위험을 고려해야 함
  - TelephoneNumber 클래스를 공개했는데 클라이언트가 이 객체 안의 지역번호를 변경한다면?
  - 이렇게 변경한 주체가 직접 호출한 클라이언트가 아니라 클라이언트의 클라이언트일 수도 있음



</br>



- 다음 중 하나를 택해야 함

- 이하 (TelephoneNumber = T, Person = P 로 명칭)

  1. 모든 객체가 T 클래스의 어느 부분이든 변경할 수 있음을 받아드린다.
     - 이렇게 하면 T 클래스가 참조 객체가 되므로 값을 참조로 전환을 실시해야 함
     - 이때 P 클래스가 T 클래스의 접근 지점이 됨
  2. 어느 주체든 P 클래스를 거치지 않고 T 클래스의 값을 변경하지 못하게 한다
     - T 클래스를 변경불가로 만들어야 한다
  3. T 클래스를 외부로 전달하기 전에 복사한 후 변경불가로 만든다
     - 하지만 이 방법은 코드를 보는 이들이 값을 변경할 수 있다는 착각을 불러 일으킴
     - 게다가 전화번호가 여기저기로 무수히 전달될 경우 클라이언트 간에 왜곡 무제가 발생할 수도 있음

  

  </br>

  

  [저자의 왈 - 2]

  - 클래스 추출은 두 결과 클래스에 따로 락을 걸 수 있어서 병렬 실행 프로그램의 생동감을 향상시키는 용도로 흔히 사용 됨
  - 두 객체에 락을 걸 필요가 없다면 이 기법을 실시하지 않아도 됨
  - 그러나 두 객체에 동시에 락을 걸어야 할 경우는 트랜잭션과 다른 종류의 공유 락 영역으로 넘어가게 됨
  - 이것은 복잡한 영역이며 대부분 얻는 것에 비해 많은 작업을 요함
