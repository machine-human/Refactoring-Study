# 필드 이동

###### Move Field

어떤 필드가 자신이 속한 클래스보다 다른 클래스에서 더 많이 사용될 때는 대상 클래스 안에 새 필드를 선언하고 그 필드 참조 부분을 전부 새 필드 참조로 수정하자

</br>

[클래스 다이어그램]

![Move Field.png](https://raw.githubusercontent.com/machine-human/Refactoring-Study/master/image/Move%20Field.PNG)

</br>

[방법]

1. 필드가 public이면 필드 캡슐화 기법을 실시하자
   
   (필드에 자주 접근하는 메서드를 옮기게 될 가능성이 높거나 그 필드에 많은 메서드가 접근할 때는 필드 자체 캡슐화를 실시)

</br>

2. 컴파일과 테스트 실시

</br>

3. 대상 클래스 안에 읽기/쓰기 메서드와 함께 필드를 작성하자

</br>

4. 대상 클래스를 컴파일하자

</br>

5. 원본 객체에서 대상 객체를 참조할 방법을 정하자

   (기존 필드나 메서드에 대상 클래스를 참조하는 기능이 있을 수도 있음)
   (없다면 그런 기능의 메서드를 간편히 작성할 수 있는지 살펴본 후)
   (쉽게 만들 수 없다면 원본 클래스에 대상 클래스를 저장할 수 있는 새 필드를 만들어야 함)
   (이러한 수정은 계속 둬도 되지만)
   (임시로 만들었다가 리팩토링 완료 후 삭제해도 됨)

</br>

6. 원본 클래스에서 필드를 삭제하자

</br>

7. 원본 필드를 참조하는 모든 부분을 대상 클래스에 있는 적절한 메서드를 참조하게 수정하자

   (변수 접근 참조 부분 : 대상 객체의 읽기 메서드 호출로 수정)

   (대입 참조 부분 : 쓰게 메서드 호출로 수정)

   (필드가 private가 아니면 원본 클래스의 모든 하위클래스를 뒤져서 필드 참조 부분을 찾아내자)

</br>

8. 컴파일과 테스트를 실시

</br>

[예제 1 - 필드 캡슐화]

- 수정 전

  ```java
  public class Account {
      private AccountType type;
      private double interestRate;
  
      private double interestForAmount_days(double amount, int days) {
          return interestRate * amount * days / 365;
      }
  }
  ```
  
  ```java
  public class AccountType {}
  ```

</br>

- 수정 후

  - Account 클래스의 interestRate 필드를 AccountType 클래스로 이동 후 Getter/Setter 생성
  - Account 클래스 안의 메서듣들을 AccountType 클래스를 사용하게끔 참조를 변경
  - Account 클래스에서 interestRate 필드 삭제 (참조 변경이 실제로 이뤄지려면 삭제해야 하기 때문)
  - 이렇게 하면 컴파일러가 참조 변경에 실패한 메서드를 쉽게 찾아낼 수 있음
  
  ```java
  public class Account {
      private AccountType type;
  
    private double interestForAmount_days(double amount, int days) {
          return type.getInterestRate() * amount * days / 365;
      }
  }
  ```
  
  ```java
  public class AccountType {
      private double interestRate;
  
      public double getInterestRate() {
          return interestRate;
      }
  
      public void setInterestRate(double interestRate) {
          this.interestRate = interestRate;
      }
  }
  ```

</br>

[예제 2 - 필드 자체 캡슐화]

- 많은 메서드가 interestRate 필드를 사용할때 필드 자체 캡슐화 실시

- 수정 전

  ```java
  public class Account {
      private AccountType type;
      private double interestRate;
  
      private double interestForAmount_days(double amount, int days) {
          return interestRate * amount * days / 365;
      }
  }
  ```
  
  ```java
   public class AccountType {}
  ```

</br>

- 수정 후

  - 위 예제와 동일하게 Account 클래스의 interestRate 필드를 AccountType 클래스로 이동 후
  - Account 클래스의 Getter/Setter 메서드의 참조만 수정
  
  ```java
  public class Account {
    private AccountType type;
  
      public double getInterestRate() {
          return type.getInterestRate();
      }
  
      public void setInterestRate(double arg) {
          type.setInterestRate(arg);
      }
  
      private double interestForAmount_days(double amount, int days) {
          return getInterestRate() * amount * days / 365;
      }
  }
  ```
  
  ```java
  public class AccountType {
      private double interestRate;
  
      public double getInterestRate() {
          return interestRate;
      }
  
      public void setInterestRate(double interestRate) {
          this.interestRate = interestRate;
      }
  }
  ```
